\hypertarget{d3d_util_8h_source}{}\doxysection{d3d\+Util.\+h}
\label{d3d_util_8h_source}\index{Common/d3dUtil.h@{Common/d3dUtil.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{4 }
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <wrl.h>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <dxgi1\_4.h>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <d3d12.h>}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <D3Dcompiler.h>}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <DirectXMath.h>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <DirectXPackedVector.h>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <DirectXColors.h>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <DirectXCollision.h>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include "{}d3dx12.h"{}}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include "{}DDSTextureLoader.h"{}}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include "{}MathHelper.h"{}}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <wincodec.h>}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{extern} \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources;}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} d3dSetDebugName(IDXGIObject* obj, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name)}
\DoxyCodeLine{32 \{}
\DoxyCodeLine{33     \textcolor{keywordflow}{if} (obj)}
\DoxyCodeLine{34     \{}
\DoxyCodeLine{35         obj-\/>SetPrivateData(WKPDID\_D3DDebugObjectName, lstrlenA(name), name);}
\DoxyCodeLine{36     \}}
\DoxyCodeLine{37 \}}
\DoxyCodeLine{38 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} d3dSetDebugName(ID3D12Device* obj, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name)}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40     \textcolor{keywordflow}{if} (obj)}
\DoxyCodeLine{41     \{}
\DoxyCodeLine{42         obj-\/>SetPrivateData(WKPDID\_D3DDebugObjectName, lstrlenA(name), name);}
\DoxyCodeLine{43     \}}
\DoxyCodeLine{44 \}}
\DoxyCodeLine{45 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} d3dSetDebugName(ID3D12DeviceChild* obj, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name)}
\DoxyCodeLine{46 \{}
\DoxyCodeLine{47     \textcolor{keywordflow}{if} (obj)}
\DoxyCodeLine{48     \{}
\DoxyCodeLine{49         obj-\/>SetPrivateData(WKPDID\_D3DDebugObjectName, lstrlenA(name), name);}
\DoxyCodeLine{50     \}}
\DoxyCodeLine{51 \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{inline} std::wstring AnsiToWString(\textcolor{keyword}{const} std::string\& str)}
\DoxyCodeLine{54 \{}
\DoxyCodeLine{55     WCHAR buffer[512];}
\DoxyCodeLine{56     MultiByteToWideChar(CP\_ACP, 0, str.c\_str(), -\/1, buffer, 512);}
\DoxyCodeLine{57     \textcolor{keywordflow}{return} std::wstring(buffer);}
\DoxyCodeLine{58 \}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60 \textcolor{comment}{/*}}
\DoxyCodeLine{61 \textcolor{comment}{\#if defined(\_DEBUG)}}
\DoxyCodeLine{62 \textcolor{comment}{    \#ifndef Assert}}
\DoxyCodeLine{63 \textcolor{comment}{    \#define Assert(x, description)                                  \(\backslash\)}}
\DoxyCodeLine{64 \textcolor{comment}{    \{                                                               \(\backslash\)}}
\DoxyCodeLine{65 \textcolor{comment}{        static bool ignoreAssert = false;                           \(\backslash\)}}
\DoxyCodeLine{66 \textcolor{comment}{        if(!ignoreAssert \&\& !(x))                                   \(\backslash\)}}
\DoxyCodeLine{67 \textcolor{comment}{        \{                                                           \(\backslash\)}}
\DoxyCodeLine{68 \textcolor{comment}{            Debug::AssertResult result = Debug::ShowAssertDialog(   \(\backslash\)}}
\DoxyCodeLine{69 \textcolor{comment}{            (L\#x), description, AnsiToWString(\_\_FILE\_\_), \_\_LINE\_\_); \(\backslash\)}}
\DoxyCodeLine{70 \textcolor{comment}{        if(result == Debug::AssertIgnore)                           \(\backslash\)}}
\DoxyCodeLine{71 \textcolor{comment}{        \{                                                           \(\backslash\)}}
\DoxyCodeLine{72 \textcolor{comment}{            ignoreAssert = true;                                    \(\backslash\)}}
\DoxyCodeLine{73 \textcolor{comment}{        \}                                                           \(\backslash\)}}
\DoxyCodeLine{74 \textcolor{comment}{                    else if(result == Debug::AssertBreak)           \(\backslash\)}}
\DoxyCodeLine{75 \textcolor{comment}{        \{                                                           \(\backslash\)}}
\DoxyCodeLine{76 \textcolor{comment}{            \_\_debugbreak();                                         \(\backslash\)}}
\DoxyCodeLine{77 \textcolor{comment}{        \}                                                           \(\backslash\)}}
\DoxyCodeLine{78 \textcolor{comment}{        \}                                                           \(\backslash\)}}
\DoxyCodeLine{79 \textcolor{comment}{    \}}}
\DoxyCodeLine{80 \textcolor{comment}{    \#endif}}
\DoxyCodeLine{81 \textcolor{comment}{\#else}}
\DoxyCodeLine{82 \textcolor{comment}{    \#ifndef Assert}}
\DoxyCodeLine{83 \textcolor{comment}{    \#define Assert(x, description)}}
\DoxyCodeLine{84 \textcolor{comment}{    \#endif}}
\DoxyCodeLine{85 \textcolor{comment}{\#endif}}
\DoxyCodeLine{86 \textcolor{comment}{    */}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{keyword}{class }\mbox{\hyperlink{classd3d_util}{d3dUtil}}}
\DoxyCodeLine{89 \{}
\DoxyCodeLine{90 \textcolor{keyword}{public}:}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} IsKeyDown(\textcolor{keywordtype}{int} vkeyCode);}
\DoxyCodeLine{93 }
\DoxyCodeLine{94     \textcolor{keyword}{static} std::string ToString(HRESULT hr);}
\DoxyCodeLine{95 }
\DoxyCodeLine{96     \textcolor{keyword}{static} UINT CalcConstantBufferByteSize(UINT byteSize)}
\DoxyCodeLine{97     \{}
\DoxyCodeLine{98         \textcolor{comment}{// Constant buffers must be a multiple of the minimum hardware}}
\DoxyCodeLine{99         \textcolor{comment}{// allocation size (usually 256 bytes).  So round up to nearest}}
\DoxyCodeLine{100         \textcolor{comment}{// multiple of 256.  We do this by adding 255 and then masking off}}
\DoxyCodeLine{101         \textcolor{comment}{// the lower 2 bytes which store all bits < 256.}}
\DoxyCodeLine{102         \textcolor{comment}{// Example: Suppose byteSize = 300.}}
\DoxyCodeLine{103         \textcolor{comment}{// (300 + 255) \& \string~255}}
\DoxyCodeLine{104         \textcolor{comment}{// 555 \& \string~255}}
\DoxyCodeLine{105         \textcolor{comment}{// 0x022B \& \string~0x00ff}}
\DoxyCodeLine{106         \textcolor{comment}{// 0x022B \& 0xff00}}
\DoxyCodeLine{107         \textcolor{comment}{// 0x0200}}
\DoxyCodeLine{108         \textcolor{comment}{// 512}}
\DoxyCodeLine{109         \textcolor{keywordflow}{return} (byteSize + 255) \& \string~255;}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112     \textcolor{keyword}{static} Microsoft::WRL::ComPtr<ID3DBlob> LoadBinary(\textcolor{keyword}{const} std::wstring\& filename);}
\DoxyCodeLine{113 }
\DoxyCodeLine{114     \textcolor{keyword}{static} Microsoft::WRL::ComPtr<ID3D12Resource> CreateDefaultBuffer(}
\DoxyCodeLine{115         ID3D12Device* device,}
\DoxyCodeLine{116         ID3D12GraphicsCommandList* cmdList,}
\DoxyCodeLine{117         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* initData,}
\DoxyCodeLine{118         UINT64 byteSize,}
\DoxyCodeLine{119         Microsoft::WRL::ComPtr<ID3D12Resource>\& uploadBuffer);}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     \textcolor{keyword}{static} Microsoft::WRL::ComPtr<ID3DBlob> CompileShader(}
\DoxyCodeLine{122         \textcolor{keyword}{const} std::wstring\& filename,}
\DoxyCodeLine{123         \textcolor{keyword}{const} D3D\_SHADER\_MACRO* defines,}
\DoxyCodeLine{124         \textcolor{keyword}{const} std::string\& entrypoint,}
\DoxyCodeLine{125         \textcolor{keyword}{const} std::string\& target);}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     \textcolor{keyword}{static} \textcolor{keywordtype}{int} LoadImageDataFromFile(BYTE** imageData, D3D12\_RESOURCE\_DESC\& resourceDescription, LPCWSTR filename, \textcolor{keywordtype}{int}\& bytesPerRow);}
\DoxyCodeLine{128     \textcolor{keyword}{static} DXGI\_FORMAT GetDXGIFormatFromWICFormat(WICPixelFormatGUID\& wicFormatGUID);}
\DoxyCodeLine{129     \textcolor{keyword}{static} WICPixelFormatGUID GetConvertToWICFormat(WICPixelFormatGUID\& wicFormatGUID);}
\DoxyCodeLine{130     \textcolor{keyword}{static} \textcolor{keywordtype}{int} GetDXGIFormatBitsPerPixel(DXGI\_FORMAT\& dxgiFormat);}
\DoxyCodeLine{131 \};}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{keyword}{class }\mbox{\hyperlink{class_dx_exception}{DxException}}}
\DoxyCodeLine{134 \{}
\DoxyCodeLine{135 \textcolor{keyword}{public}:}
\DoxyCodeLine{136     \mbox{\hyperlink{class_dx_exception}{DxException}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{137     \mbox{\hyperlink{class_dx_exception}{DxException}}(HRESULT hr, \textcolor{keyword}{const} std::wstring\& functionName, \textcolor{keyword}{const} std::wstring\& filename, \textcolor{keywordtype}{int} lineNumber);}
\DoxyCodeLine{138 }
\DoxyCodeLine{139     std::wstring ToString()\textcolor{keyword}{const};}
\DoxyCodeLine{140 }
\DoxyCodeLine{141     HRESULT ErrorCode = S\_OK;}
\DoxyCodeLine{142     std::wstring FunctionName;}
\DoxyCodeLine{143     std::wstring Filename;}
\DoxyCodeLine{144     \textcolor{keywordtype}{int} LineNumber = -\/1;}
\DoxyCodeLine{145 \};}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{comment}{// Defines a subrange of geometry in a MeshGeometry.  This is for when multiple}}
\DoxyCodeLine{148 \textcolor{comment}{// geometries are stored in one vertex and index buffer.  It provides the offsets}}
\DoxyCodeLine{149 \textcolor{comment}{// and data needed to draw a subset of geometry stores in the vertex and index }}
\DoxyCodeLine{150 \textcolor{comment}{// buffers so that we can implement the technique described by Figure 6.3.}}
\DoxyCodeLine{151 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_submesh_geometry}{SubmeshGeometry}}}
\DoxyCodeLine{152 \{}
\DoxyCodeLine{153     UINT IndexCount = 0;}
\DoxyCodeLine{154     UINT StartIndexLocation = 0;}
\DoxyCodeLine{155     INT BaseVertexLocation = 0;}
\DoxyCodeLine{156 }
\DoxyCodeLine{157     \textcolor{comment}{// Bounding box of the geometry defined by this submesh. }}
\DoxyCodeLine{158     \textcolor{comment}{// This is used in later chapters of the book.}}
\DoxyCodeLine{159     DirectX::BoundingBox Bounds;}
\DoxyCodeLine{160 \};}
\DoxyCodeLine{161 }
\DoxyCodeLine{162 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_mesh_geometry}{MeshGeometry}}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 \{}
\DoxyCodeLine{165     \textcolor{comment}{// Give it a name so we can look it up by name.}}
\DoxyCodeLine{166     std::string Name;}
\DoxyCodeLine{167 }
\DoxyCodeLine{168     \textcolor{comment}{// System memory copies.  Use Blobs because the vertex/index format can be generic.}}
\DoxyCodeLine{169     \textcolor{comment}{// It is up to the client to cast appropriately. }}
\DoxyCodeLine{170 }
\DoxyCodeLine{171     Microsoft::WRL::ComPtr<ID3DBlob> VertexBufferCPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{172     Microsoft::WRL::ComPtr<ID3DBlob> IndexBufferCPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{173     Microsoft::WRL::ComPtr<ID3DBlob> ColorBufferCPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 }
\DoxyCodeLine{176     Microsoft::WRL::ComPtr<ID3D12Resource> VertexBufferGPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{177     Microsoft::WRL::ComPtr<ID3D12Resource> IndexBufferGPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{178     Microsoft::WRL::ComPtr<ID3D12Resource> ColorBufferGPU = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{179 }
\DoxyCodeLine{180 }
\DoxyCodeLine{181     Microsoft::WRL::ComPtr<ID3D12Resource> VertexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{182     Microsoft::WRL::ComPtr<ID3D12Resource> IndexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{183     Microsoft::WRL::ComPtr<ID3D12Resource> ColorBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 }
\DoxyCodeLine{186 }
\DoxyCodeLine{187     \textcolor{comment}{// Data about the buffers.}}
\DoxyCodeLine{188     UINT VertexByteStride = 0;}
\DoxyCodeLine{189     UINT VertexBufferByteSize = 0;}
\DoxyCodeLine{190     DXGI\_FORMAT IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{191     UINT IndexBufferByteSize = 0;}
\DoxyCodeLine{192     UINT ColorByteStride = 0;}
\DoxyCodeLine{193     UINT ColorBufferByteSize = 0;}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 }
\DoxyCodeLine{196     \textcolor{comment}{// A MeshGeometry may store multiple geometries in one vertex/index buffer.}}
\DoxyCodeLine{197     \textcolor{comment}{// Use this container to define the Submesh geometries so we can draw}}
\DoxyCodeLine{198     \textcolor{comment}{// the Submeshes individually.}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200     std::unordered\_map<std::string, SubmeshGeometry> DrawArgs;}
\DoxyCodeLine{201 }
\DoxyCodeLine{202     D3D12\_VERTEX\_BUFFER\_VIEW VertexBufferView()\textcolor{keyword}{const}}
\DoxyCodeLine{203 \textcolor{keyword}{}}
\DoxyCodeLine{204 \textcolor{keyword}{    }\{}
\DoxyCodeLine{205         D3D12\_VERTEX\_BUFFER\_VIEW vbv;}
\DoxyCodeLine{206         vbv.BufferLocation = VertexBufferGPU-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{207         vbv.StrideInBytes = VertexByteStride;}
\DoxyCodeLine{208         vbv.SizeInBytes = VertexBufferByteSize;}
\DoxyCodeLine{209 }
\DoxyCodeLine{210         \textcolor{keywordflow}{return} vbv;}
\DoxyCodeLine{211     \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213     D3D12\_INDEX\_BUFFER\_VIEW IndexBufferView()\textcolor{keyword}{const}}
\DoxyCodeLine{214 \textcolor{keyword}{}}
\DoxyCodeLine{215 \textcolor{keyword}{    }\{}
\DoxyCodeLine{216         D3D12\_INDEX\_BUFFER\_VIEW ibv;}
\DoxyCodeLine{217         ibv.BufferLocation = IndexBufferGPU-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{218         ibv.Format = IndexFormat;}
\DoxyCodeLine{219         ibv.SizeInBytes = IndexBufferByteSize;}
\DoxyCodeLine{220 }
\DoxyCodeLine{221         \textcolor{keywordflow}{return} ibv;}
\DoxyCodeLine{222     \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224     D3D12\_VERTEX\_BUFFER\_VIEW ColorBufferView()\textcolor{keyword}{const}}
\DoxyCodeLine{225 \textcolor{keyword}{}}
\DoxyCodeLine{226 \textcolor{keyword}{    }\{}
\DoxyCodeLine{227         D3D12\_VERTEX\_BUFFER\_VIEW cbv;}
\DoxyCodeLine{228         cbv.BufferLocation = ColorBufferGPU-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{229         cbv.StrideInBytes = ColorByteStride;}
\DoxyCodeLine{230         cbv.SizeInBytes = ColorBufferByteSize;}
\DoxyCodeLine{231 }
\DoxyCodeLine{232         \textcolor{keywordflow}{return} cbv;}
\DoxyCodeLine{233     \}}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 }
\DoxyCodeLine{236     \textcolor{comment}{// We can free this memory after we finish upload to the GPU.}}
\DoxyCodeLine{237     \textcolor{keywordtype}{void} DisposeUploaders()}
\DoxyCodeLine{238     \{}
\DoxyCodeLine{239         VertexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{240         IndexBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{241         ColorBufferUploader = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{242     \}}
\DoxyCodeLine{243 \};}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 }
\DoxyCodeLine{246 }
\DoxyCodeLine{247 }
\DoxyCodeLine{248 }
\DoxyCodeLine{249 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_light}{Light}}}
\DoxyCodeLine{250 \{}
\DoxyCodeLine{251     DirectX::XMFLOAT3 Strength = \{ 0.5f, 0.5f, 0.5f \};}
\DoxyCodeLine{252     \textcolor{keywordtype}{float} FalloffStart = 1.0f;                          \textcolor{comment}{// point/spot light only}}
\DoxyCodeLine{253     DirectX::XMFLOAT3 Direction = \{ 0.0f, -\/1.0f, 0.0f \};\textcolor{comment}{// directional/spot light only}}
\DoxyCodeLine{254     \textcolor{keywordtype}{float} FalloffEnd = 10.0f;                           \textcolor{comment}{// point/spot light only}}
\DoxyCodeLine{255     DirectX::XMFLOAT3 Position = \{ 0.0f, 0.0f, 0.0f \};  \textcolor{comment}{// point/spot light only}}
\DoxyCodeLine{256     \textcolor{keywordtype}{float} SpotPower = 64.0f;                            \textcolor{comment}{// spot light only}}
\DoxyCodeLine{257 \};}
\DoxyCodeLine{258 }
\DoxyCodeLine{259 \textcolor{preprocessor}{\#define MaxLights 16}}
\DoxyCodeLine{260 }
\DoxyCodeLine{261 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_material_constants}{MaterialConstants}}}
\DoxyCodeLine{262 \{}
\DoxyCodeLine{263     DirectX::XMFLOAT4 DiffuseAlbedo = \{ 1.0f, 1.0f, 1.0f, 1.0f \};}
\DoxyCodeLine{264     DirectX::XMFLOAT3 FresnelR0 = \{ 0.01f, 0.01f, 0.01f \};}
\DoxyCodeLine{265     \textcolor{keywordtype}{float} Roughness = 0.25f;}
\DoxyCodeLine{266 }
\DoxyCodeLine{267     \textcolor{comment}{// Used in texture mapping.}}
\DoxyCodeLine{268     DirectX::XMFLOAT4X4 MatTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{269 \};}
\DoxyCodeLine{270 }
\DoxyCodeLine{271 \textcolor{comment}{// Simple struct to represent a material for our demos.  A production 3D engine}}
\DoxyCodeLine{272 \textcolor{comment}{// would likely create a class hierarchy of Materials.}}
\DoxyCodeLine{273 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_material}{Material}}}
\DoxyCodeLine{274 \{}
\DoxyCodeLine{275     \textcolor{comment}{// Unique material name for lookup.}}
\DoxyCodeLine{276     std::string Name;}
\DoxyCodeLine{277 }
\DoxyCodeLine{278     \textcolor{comment}{// Index into constant buffer corresponding to this material.}}
\DoxyCodeLine{279     \textcolor{keywordtype}{int} MatCBIndex = -\/1;}
\DoxyCodeLine{280 }
\DoxyCodeLine{281     \textcolor{comment}{// Index into SRV heap for diffuse texture.}}
\DoxyCodeLine{282     \textcolor{keywordtype}{int} DiffuseSrvHeapIndex = -\/1;}
\DoxyCodeLine{283 }
\DoxyCodeLine{284     \textcolor{comment}{// Index into SRV heap for normal texture.}}
\DoxyCodeLine{285     \textcolor{keywordtype}{int} NormalSrvHeapIndex = -\/1;}
\DoxyCodeLine{286 }
\DoxyCodeLine{287     \textcolor{comment}{// Dirty flag indicating the material has changed and we need to update the constant buffer.}}
\DoxyCodeLine{288     \textcolor{comment}{// Because we have a material constant buffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{289     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify a material we should set }}
\DoxyCodeLine{290     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{291     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{292 }
\DoxyCodeLine{293     \textcolor{comment}{// Material constant buffer data used for shading.}}
\DoxyCodeLine{294     DirectX::XMFLOAT4 DiffuseAlbedo = \{ 1.0f, 1.0f, 1.0f, 1.0f \};}
\DoxyCodeLine{295     DirectX::XMFLOAT3 FresnelR0 = \{ 0.01f, 0.01f, 0.01f \};}
\DoxyCodeLine{296     \textcolor{keywordtype}{float} Roughness = .25f;}
\DoxyCodeLine{297     DirectX::XMFLOAT4X4 MatTransform = MathHelper::Identity4x4();}
\DoxyCodeLine{298 \};}
\DoxyCodeLine{299 }
\DoxyCodeLine{300 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_texture}{Texture}}}
\DoxyCodeLine{301 \{}
\DoxyCodeLine{302     \textcolor{comment}{// Unique material name for lookup.}}
\DoxyCodeLine{303     std::string Name;}
\DoxyCodeLine{304 }
\DoxyCodeLine{305     std::wstring Filename;}
\DoxyCodeLine{306 }
\DoxyCodeLine{307     Microsoft::WRL::ComPtr<ID3D12Resource> Resource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{308     Microsoft::WRL::ComPtr<ID3D12Resource> UploadHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{309 \};}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 \textcolor{preprocessor}{\#ifndef ThrowIfFailed}}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#define ThrowIfFailed(x)                                              \(\backslash\)}}
\DoxyCodeLine{313 \textcolor{preprocessor}{\{                                                                     \(\backslash\)}}
\DoxyCodeLine{314 \textcolor{preprocessor}{    HRESULT hr\_\_ = (x);                                               \(\backslash\)}}
\DoxyCodeLine{315 \textcolor{preprocessor}{    std::wstring wfn = AnsiToWString(\_\_FILE\_\_);                       \(\backslash\)}}
\DoxyCodeLine{316 \textcolor{preprocessor}{    if(FAILED(hr\_\_)) \{ throw DxException(hr\_\_, L\#x, wfn, \_\_LINE\_\_); \} \(\backslash\)}}
\DoxyCodeLine{317 \textcolor{preprocessor}{\}}}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{319 }
\DoxyCodeLine{320 \textcolor{preprocessor}{\#ifndef ReleaseCom}}
\DoxyCodeLine{321 \textcolor{preprocessor}{\#define ReleaseCom(x) \{ if(x)\{ x-\/>Release(); x = 0; \} \}}}
\DoxyCodeLine{322 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
